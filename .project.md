# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Rewind is a Tauri-based desktop application that monitors and analyzes user activity (keyboard, mouse, screenshots) using AI to provide intelligent insights and task recommendations. It features a three-layer architecture:

1. **Perception Layer** - Captures raw user input (keyboard, mouse, screenshots)
2. **Processing Layer** - Filters, summarizes, and organizes events using LLM
3. **Consumption Layer** - Provides intelligent analysis and agent-based task execution

## Technology Stack

### Frontend

- **Framework**: React 19 + TypeScript 5
- **Build Tool**: Vite 6
- **Routing**: React Router 7
- **State Management**: Zustand 5 (with persist middleware)
- **UI Components**: shadcn/ui (Radix UI primitives)
- **Styling**: Tailwind CSS 4
- **Forms**: React Hook Form + Zod
- **Date Handling**: date-fns
- **Notifications**: Sonner

### Backend

- **Runtime**: Tauri 2.x (Rust)
- **Python Backend**: PyTauri 0.8 (Python ↔ Rust bridge)
- **Database**: SQLite
- **LLM Integration**: OpenAI API (configurable)
- **Image Processing**: OpenCV, PIL
- **System Monitoring**: pynput (keyboard/mouse), mss (screenshots)

## Project Setup

### Initial Environment Setup

Run one of these commands from the project root to initialize everything:

```bash
# macOS / Linux (recommended)
pnpm setup

# Windows
pnpm setup:win

# Or manually run all steps
pnpm setup-all
```

This automatically:

1. Installs frontend dependencies (`pnpm install`)
2. Initializes Python environment (`uv sync` - creates `.venv` in project root)
3. Verifies i18n translations (`pnpm check-i18n`)

**Key Point**: Python environment is initialized at the **project root**, not in `src-tauri/`. The `pyproject.toml` is at the project root.

## Development Commands

### Frontend Development

```bash
# Start development server (frontend only)
pnpm dev

# Build TypeScript and frontend
pnpm build

# Preview production build
pnpm preview

# Format code
pnpm format

# Check formatting (CI)
pnpm lint

# Validate i18n translation keys consistency
pnpm check-i18n
```

### Tauri Development

```bash
# Start Tauri app in development mode (includes frontend + backend)
pnpm tauri dev

# Build production app
pnpm tauri build

# Rebuild Tauri without launching (regenerates PyTauri client)
pnpm tauri build --ci
```

### Backend Development

Backend code is written in Python and integrated via PyTauri. Key points:

- Backend entry point: Python module exposed via `src-tauri/src/lib.rs`
- Main code locations: `src-tauri/python/tauri_app/` and symlinked `backend/`
- PyTauri automatically generates TypeScript client in `src/client/` (DO NOT manually edit)
- Communication: Frontend → PyTauri Client → Rust → Python

**After adding Python modules or dependencies:**

```bash
# From project root - re-sync Python environment
pnpm setup-backend

# or manually
uv sync

# Then rebuild Tauri to regenerate TypeScript client
pnpm tauri dev
```

### Project Maintenance

```bash
# Build distribution bundles (macOS/Linux)
pnpm bundle

# Build distribution bundles (Windows)
pnpm bundle:win

# Clean build artifacts
pnpm clean
```

## Internationalization (i18n)

The project uses **TypeScript-first i18n** with automatic type safety for translations:

- **Translation files**: `src/locales/{en.ts, zh-CN.ts}`
- **English file** (`en.ts`) is the source of truth and defines the TypeScript types
- **Type checking**: Prevents using non-existent translation keys at compile time
- **Validation**: Run `pnpm check-i18n` to ensure all languages have consistent keys

### Adding Translations

1. Add new keys to `src/locales/en.ts`:

   ```typescript
   export const en = {
     common: {
       save: 'Save',
       cancel: 'Cancel'
     },
     myFeature: {
       title: 'Feature Title'
     }
   } as const
   ```

2. Add corresponding keys to `src/locales/zh-CN.ts` with same structure and keys

3. Run validation: `pnpm check-i18n`

4. Use in components: `const { t } = useTranslation(); t('myFeature.title')`

See `docs/i18n.md` for detailed i18n documentation.

## Architecture Guidelines

### Frontend Architecture

**Component Hierarchy:**

```
Pages (src/views/)                    # Data fetching, state management
  ├─ Containers (src/components/)     # Business logic, composition
  │   └─ Components                   # Pure presentation
  │       └─ Primitives (shadcn-ui)   # Base UI components
```

**State Management Strategy:**

- **Zustand Stores** (`src/lib/stores/`) for cross-component state
  - `activity.ts` - Timeline data and filters
  - `agents.ts` - Agent tasks and execution state
  - `dashboard.ts` - Metrics and statistics
  - `settings.ts` - LLM configuration
  - `ui.ts` - UI state (sidebar, menu selection)
- **Props/Callbacks** for parent-child communication
- **Context** for theme and global configuration
- **Tauri Events** for backend → frontend real-time updates

**Routing Strategy:**

- React Router with lazy-loaded views for code splitting
- Menu configuration in `src/lib/config/menu.ts` drives both routing and sidebar
- UI state syncs with router location to maintain menu highlighting

**Communication Patterns:**

```
User Action → Component Handler → Zustand Action → Service Layer → PyTauri Client → Backend
                                                                                      ↓
Frontend Component ← Zustand Store Update ← Response/Tauri Event ←←←←←←←←←←←←←←←←←←←←←
```

### Backend Architecture

**Data Flow:**

```
Raw Records (滑动窗口 20s)
    ↓ 每10秒处理
Events (带 events_summary)
    ↓ LLM 总结 + 活动合并判断
Activity (持久化到 SQLite)
    ↓ 智能分析
Agent 任务推荐 → TODO
```

**Agent System:**

- Factory pattern for extensible agents (`AgentFactory`)
- Base class `BaseAgent` with `execute()` and `can_handle()` methods
- Tasks have states: `todo`, `doing`, `done`, `cancelled`
- Support parallel execution

**Data Models:**

- `RawRecord` - Raw input events (timestamp, type, data)
- `Event` - Filtered and summarized events
- `Activity` - Grouped related events with LLM-generated description
- `Task` - Agent tasks with execution state

### Key Design Patterns

1. **Configuration-Driven Menu**: Menu items defined in `src/lib/config/menu.ts`

   - Supports position grouping (main/bottom)
   - Badge notifications
   - Dynamic visibility control

2. **PyTauri Client Auto-Generation**:

   - Backend changes trigger automatic TypeScript client generation
   - Located in `src/client/` (marked as auto-generated)
   - Never manually edit client files

3. **Service Layer Pattern**:

   - Services in `src/lib/services/` wrap PyTauri client calls
   - Handles error logging and retry logic
   - Used by Zustand store actions

4. **Store Subscription Optimization**:

   ```typescript
   // ✅ Good: Selective subscription
   const tasks = useAgentsStore((state) => state.tasks)

   // ❌ Bad: Subscribe to entire store
   const store = useAgentsStore()
   ```

5. **Real-Time Updates via Tauri Events**:

   ```typescript
   import { listen } from '@tauri-apps/api/event'

   useEffect(() => {
     const unlisten = listen('agent-task-update', (event) => {
       updateTaskStatus(event.payload)
     })
     return () => unlisten.then((fn) => fn())
   }, [])
   ```

## File Structure Conventions

### Do Not Edit

- `src/client/` - Auto-generated PyTauri client code
- `src/components/shadcn-ui/` - Generated shadcn/ui components (edit via CLI)
- `src/types/auto-imports.d.ts` - Auto-generated types

### Key Directories

- `src/views/` - Page-level components (route targets)
- `src/layouts/` - Layout wrappers (MainLayout, AuthLayout)
- `src/lib/stores/` - Zustand state management
- `src/lib/services/` - API service layer (wraps PyTauri client)
- `src/lib/types/` - TypeScript type definitions
- `src/lib/config/` - Configuration files (menu, constants)
- `src/components/` - Reusable components organized by feature
- `src/hooks/` - Custom React hooks

### Naming Conventions

- **Components**: PascalCase (`ActivityTimeline`)
- **Hooks**: camelCase with `use` prefix (`useActivityStore`)
- **Types**: PascalCase (`Activity`, `AgentTask`)
- **Constants**: UPPER_SNAKE_CASE (`MAX_RETRY_COUNT`)

## Frontend Data Flow & Real-Time Updates

### Activity Timeline Data Synchronization

The activity timeline uses a **version-based incremental update system** combined with **Tauri events**:

**Frontend Data Sources:**
1. **Initial Load** - `fetchActivityTimeline()` loads paginated activity data from database
2. **Incremental Updates** - `fetchActivitiesIncremental()` fetches new activities based on version number
3. **Real-Time Events** - Tauri events (`activity-created`, `activity-updated`, `activity-deleted`) trigger updates

**Key Frontend Components:**
- `useActivityIncremental()` - Hook that subscribes to `activity-created` event and fetches incremental updates when window is at top (sliding window strategy)
- `Activity/index.tsx` - View that manages timeline display, infinite scroll, and event debouncing
- `useInfiniteScroll()` - Custom hook for bidirectional infinite scrolling with Intersection Observer API
- `fetchActivityTimeline()` - Service function that queries timeline data from Tauri SQL plugin

**Important Implementation Details:**

1. **Event Debouncing** - Activity updates/deletes are debounced (300ms) to batch multiple events
2. **Incremental Updates** - New activities are merged at the top of timeline, with deduplication by date
3. **Safe Date Handling** - All timestamps are validated to prevent "Invalid time value" errors:
   - `mapActivity()`, `mapEvent()`, `mapRecord()` in `db.ts` include defensive parsing
   - Fallback to `Date.now()` for invalid timestamps
   - ActivityItem component handles undefined timestamps gracefully
4. **Data Consistency** - `fetchActivitiesIncremental()` ensures new activities have complete fields:
   - `id`, `name`, `description`, `timestamp`, `startTime`, `endTime`
   - `eventSummaries` array (mapped from backend's `sourceEvents`)

**Timeline State Management:**
- `useActivityStore` tracks: `timelineData`, `topOffset`, `bottomOffset`, `currentMaxVersion`
- Version-based updates prevent duplicate activities
- Maximum 100 date blocks maintained in memory
- UI state (expanded items) cached separately from timeline data

### Data Structure Mappings

Backend → Frontend conversions (especially in `fetchActivitiesIncremental`):
- `startTime` (ISO string) → `timestamp` (milliseconds)
- `sourceEvents` → `eventSummaries` with nested `events` array
- `activity.description` → `activity.name` (for display)
- `endTime` fallback to `startTime` if missing

## Common Patterns

### Adding a New Page

1. Create view component in `src/views/NewFeature/index.tsx`
2. Add menu item to `src/lib/config/menu.ts`
3. Add route in `src/routes/Index.tsx` with lazy loading:
   ```typescript
   const NewFeatureView = lazy(() => import('@/views/NewFeature'))
   ```
4. Create store if needed in `src/lib/stores/newFeature.ts`
5. Create service layer in `src/lib/services/newFeature/index.ts`

### Working with Universal API Handler System

The project uses a **universal `@api_handler` decorator** that automatically registers backend functions for **both PyTauri and FastAPI** frameworks, eliminating code duplication.

**Adding a New API Handler:**

1. Create handler function in `backend/handlers/` (e.g., `my_module.py`):

   ```python
   from . import api_handler
   from models import MyRequest

   @api_handler(
       body=MyRequest,           # Pydantic model for request validation
       method="POST",            # HTTP method (for FastAPI)
       path="/my-endpoint",      # Custom path (for FastAPI)
       tags=["my-module"]        # API tags (for FastAPI)
   )
   async def my_handler(body: MyRequest) -> dict:
       """Handler description (auto-converted to API docs)"""
       return {"success": True, "data": body.field1}
   ```

2. Add Request Model in `backend/models/requests.py`:

   ```python
   from .base import BaseModel

   class MyRequest(BaseModel):
       """Request model inherits camelCase conversion"""
       field1: str
       field2: int = 100  # With default
   ```

3. Import new module in `backend/handlers/__init__.py`:

   ```python
   from . import greeting, perception, processing, my_module
   ```

4. Regenerate TypeScript client:

   ```bash
   pnpm tauri dev  # or pnpm tauri:dev:gen-ts
   ```

5. Use in frontend service layer:

   ```typescript
   import { apiClient } from '@/lib/client'

   export async function callMyHandler(data: any) {
     return await apiClient.myHandler({ field1: data.field1, field2: data.field2 })
   }
   ```

**Key Features:**

- **Single Definition**: Write handler once, works for both PyTauri (desktop) and FastAPI (web API)
- **Auto-Registration**: No manual command registration needed
- **Type Safety**: Pydantic models auto-generate TypeScript types
- **CamelCase Conversion**: Python `snake_case` ↔ JavaScript `camelCase` automatic
- **API Documentation**: FastAPI auto-generates OpenAPI/Swagger docs

**Handler Parameters:**

- No body parameter → Handler takes no arguments (e.g., `get_stats()`)
- With body parameter → Must use Pydantic model for validation

**Example Handlers:** See `backend/handlers/{greeting.py, perception.py, processing.py}`

**Testing FastAPI Routes:**

```bash
# Run FastAPI server (development/testing only)
uv run python backend/api/fastapi_app.py

# Visit http://localhost:8000/docs for Swagger UI
```

### Adding a New Agent

1. Extend `BaseAgent` in Python backend
2. Implement `execute()` and `can_handle()` methods
3. Register in `AgentFactory`
4. Update `AgentType` enum in `src/lib/types/agents.ts`
5. Add UI configuration in Agents view

## Performance Considerations

- **Lazy Loading**: All route components use React.lazy
- **Virtual Scrolling**: Use for long lists (activity timeline)
- **Memoization**: Apply React.memo to pure presentational components
- **Store Subscriptions**: Always use selectors to minimize re-renders
- **Image Optimization**: Backend compresses screenshots and uses perceptual hashing for deduplication
- **Batch Processing**: Backend processes events every 10 seconds to reduce LLM calls

## Important Files

**Documentation:**

- `docs/development.md` - **START HERE**: Complete setup and development workflow guide
- `docs/frontend.md` - Comprehensive frontend architecture documentation
- `docs/backend.md` - Backend system design documentation
- `docs/i18n.md` - Internationalization configuration and usage
- `backend/handlers/README.md` - Universal API handler system documentation

**Frontend:**

- `src/lib/config/menu.ts` - Menu configuration (affects routing and UI)
- `src/routes/Index.tsx` - Application routing definition
- `src/lib/stores/` - Zustand state management stores
- `src/lib/client/` - Auto-generated PyTauri TypeScript client (DO NOT EDIT)

**Backend:**

- `backend/handlers/__init__.py` - Universal API handler decorator and registration system
- `backend/handlers/{greeting,perception,processing}.py` - API handler modules
- `backend/models/base.py` - Pydantic BaseModel with camelCase conversion
- `backend/models/requests.py` - Request model definitions
- `src-tauri/python/tauri_app/__init__.py` - PyTauri command registration entry point

**Configuration:**

- `src-tauri/src/lib.rs` - Rust-Python bridge configuration
- `src-tauri/Cargo.toml` - Rust dependencies including PyTauri
- `pyproject.toml` - Python project configuration and dependencies (at project root)

## Common Frontend Patterns & Best Practices

### Defensive Data Handling

The codebase prioritizes defensive programming to handle edge cases gracefully:

1. **Date/Timestamp Validation**:
   ```typescript
   // ✅ Safe date parsing with fallback
   const parseDate = (dateStr: string | undefined | null): number => {
     if (!dateStr) return Date.now()
     const parsed = new Date(dateStr).getTime()
     return isNaN(parsed) ? Date.now() : parsed
   }
   ```

2. **Optional Property Access**:
   ```typescript
   // ✅ Always use optional chaining for potentially undefined fields
   {activity.eventSummaries?.length ?? 0}
   {(activity.eventSummaries ?? []).map(...)}
   ```

3. **Loading State Awareness**:
   - Check `loading || isRefreshing || loadingMore` before showing empty states
   - Show loading indicator when data is loading, empty state only when truly empty

### UI State Management Patterns

1. **Store Subscriptions** - Use selectors to subscribe only to needed fields:
   ```typescript
   const timelineData = useActivityStore((state) => state.timelineData)
   const loading = useActivityStore((state) => state.loading)
   // Not: const state = useActivityStore() ❌
   ```

2. **Infinite Scroll** - `useInfiniteScroll()` handles edge cases:
   - Prevents multiple concurrent loads with `isLoadingRef`
   - Continues monitoring even after initial load
   - Gracefully handles missing sentinel elements

3. **Event Debouncing** - Real-time updates are debounced to avoid rapid re-renders:
   - Activity updates: 300ms debounce
   - Implementation: `useRef` for timer management, cleanup on unmount

### Data Transformation Best Practices

When mapping backend data to frontend (especially in service layer):
1. Explicitly set all required fields (don't rely on spread operator)
2. Convert units consistently (timestamps: ISO string → milliseconds)
3. Provide sensible defaults for missing data
4. Add debug logging for data validation failures

## Special Notes

- **TypeScript Strict Mode**: Project uses strict TypeScript settings
- **Path Aliases**: Use `@/*` for imports from `src/`
- **Theme System**: next-themes provider for light/dark mode
- **Form Validation**: Use React Hook Form + Zod schema validation
- **Error Boundaries**: Wrap major sections for graceful error handling
- **No Auto-Imports Config**: Project does not use unplugin-auto-import despite dependency presence
- **PyTauri Handler Requirements**: All handlers with parameters MUST use a single `body` parameter with a Pydantic model. PyTauri does NOT support direct function parameters (e.g., `def handler(name: str)` will fail - use `def handler(body: Person)` instead)
- **Activity Timeline UI**: Always maintains consistent styling across new and existing items. New items get subtle entrance animation but same visual appearance as existing items.

## Python Environment (Important)

- **Python location**: `pyproject.toml` is at **project root** (not in src-tauri/)
- **Virtual env**: `.venv` is created at **project root** when running `uv sync`
- **Command**: Always run `uv sync` or `pnpm setup-backend` from **project root**
- **Python code**: Located in `src-tauri/python/tauri_app/` and symlinked `backend/`
- **After module changes**: Must run `pnpm setup-backend` before `pnpm tauri dev` to regenerate TypeScript client
