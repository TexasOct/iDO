# Rewind Project Rule

This file provides guidance to LLM when working with code in this repository.

## Project Overview

Rewind is a Tauri-based desktop application that monitors and analyzes user activity (keyboard, mouse, screenshots) using AI to provide intelligent insights and task recommendations. It features a three-layer architecture:

1. **Perception Layer** - Captures raw user input (keyboard, mouse, screenshots)
2. **Processing Layer** - Filters, summarizes, and organizes events using LLM
3. **Consumption Layer** - Provides intelligent analysis and agent-based task execution

## Technology Stack

### Frontend

- **Framework**: React 19 + TypeScript 5
- **Build Tool**: Vite 6
- **Routing**: React Router 7
- **State Management**: Zustand 5 (with persist middleware)
- **UI Components**: shadcn/ui (Radix UI primitives)
- **Styling**: Tailwind CSS 4
- **Forms**: React Hook Form + Zod
- **Date Handling**: date-fns
- **Notifications**: Sonner

### Backend

- **Runtime**: Tauri 2.x (Rust)
- **Python Backend**: PyTauri 0.8 (Python ↔ Rust bridge)
- **Database**: SQLite
- **LLM Integration**: OpenAI API (configurable)
- **Image Processing**: OpenCV, PIL
- **System Monitoring**:
  - **Keyboard/Mouse**: Platform-specific implementations (factory pattern)
    - macOS: PyObjC NSEvent (keyboard), pynput (mouse)
    - Windows: pynput (extensible to Win32 API)
    - Linux: pynput (extensible to X11/evdev)
  - **Screenshots**: mss (cross-platform)

## Quick Command Reference

Essential commands for common development tasks:

```bash
# First time setup
pnpm setup                    # macOS/Linux - installs all dependencies
pnpm setup:win                # Windows - installs all dependencies
git config core.autocrlf false # Windows only - prevent line ending issues

# Development
pnpm dev                      # Frontend only (fastest, http://localhost:5173)
pnpm tauri:dev:gen-ts         # Full app + TS client generation (recommended)
uvicorn app:app --reload      # Backend API only (http://localhost:8000/docs)

# After Python changes
pnpm setup-backend            # Re-sync Python environment at project root
pnpm tauri dev                # Restart with new Python modules

# Quality checks
pnpm format                   # Format code (Prettier)
pnpm lint                     # Check formatting (CI validation)
pnpm check-i18n               # Validate translation consistency

# Build
pnpm tauri build              # Production build
pnpm clean                    # Clean build artifacts
```

## Development Commands

### Initial Setup

Run one of these commands from the project root to initialize everything:

```bash
# macOS / Linux (recommended)
pnpm setup

# Windows
pnpm setup:win

# Or manually run all steps
pnpm setup-all
```

This automatically:
1. Installs frontend dependencies (`pnpm install`)
2. Initializes Python environment (`uv sync` - creates `.venv` in project root)
3. Verifies i18n translations (`pnpm check-i18n`)

**Critical**: Python environment is at **project root**, not `src-tauri/`. The `pyproject.toml` is at the project root.

#### Windows-Specific Setup

**Important:** Windows and Unix systems have different line endings. To prevent git from causing issues:

```bash
# Run immediately after cloning (BEFORE any development)
git config core.autocrlf false
```

This prevents git from automatically converting line endings, which can cause spurious file changes and merge conflicts. See [Pitfall 5](#pitfall-5-windows-line-endings) for more details.

**PowerShell Execution Policy:**
Some Windows setup scripts may require adjusting PowerShell's execution policy. The setup scripts (`setup-env.ps1`, etc.) use the `-ExecutionPolicy Bypass` flag to handle this automatically.

### Common Development Workflows

**Frontend-only development** (fastest iteration):
```bash
pnpm dev  # http://localhost:5173
```

**Full application development** (with backend):
```bash
pnpm tauri:dev:gen-ts  # Recommended - auto-generates TypeScript client
# OR
pnpm tauri dev  # Without regenerating client
```

**Backend API development** (standalone FastAPI):
```bash
uvicorn app:app --reload  # http://localhost:8000/docs
# OR
uv run python app.py
```

**After adding Python modules or dependencies**:
```bash
pnpm setup-backend  # Re-sync Python environment
pnpm tauri dev      # Regenerate TypeScript client
```

### Code Quality

```bash
pnpm format          # Format code (Prettier)
pnpm lint            # Check formatting (CI)
pnpm check-i18n      # Validate translation keys
pnpm build           # Build TypeScript and frontend
pnpm tauri build     # Build production app
pnpm clean           # Clean build artifacts
```

## Architecture Guidelines

### Three-Layer Backend Architecture

```
┌──────────────────────────────────────────────────────────┐
│              Consumption Layer (消费层)                  │
│              AI 分析 → 智能推荐 → Agent 执行            │
└──────────────────────────────────────────────────────────┘
                          ▲
┌──────────────────────────────────────────────────────────┐
│              Processing Layer (处理层)                   │
│       事件筛选 → LLM总结 → 活动合并 → 数据库存储        │
└──────────────────────────────────────────────────────────┘
                          ▲
┌──────────────────────────────────────────────────────────┐
│              Perception Layer (感知层)                   │
│         键盘监控 → 鼠标监控 → 屏幕截图采集              │
└──────────────────────────────────────────────────────────┘
```

**Data Flow:**
```
Raw Records (20s sliding window)
    ↓ [Every 10s]
Events (with events_summary)
    ↓ [LLM summarization + activity merging]
Activity (persisted to SQLite)
    ↓ [Intelligent analysis]
Agent Tasks → TODO
```

### Frontend Architecture

**Component Hierarchy:**
```
Pages (src/views/)                    # Data fetching, state management
  ├─ Containers (src/components/)     # Business logic, composition
  │   └─ Components                   # Pure presentation
  │       └─ Primitives (shadcn-ui)   # Base UI components
```

**State Management Strategy:**
- **Zustand Stores** (`src/lib/stores/`) for cross-component state
  - `activity.ts` - Timeline data and filters
  - `agents.ts` - Agent tasks and execution state
  - `chat.ts` - Chat conversation state
  - `dashboard.ts` - Metrics and statistics
  - `insights.ts` - AI insights data
  - `models.ts` - LLM model configuration
  - `settings.ts` - Application settings
  - `ui.ts` - UI state (sidebar, menu selection)
  - `user.ts` - User profile and preferences
  - `permissions.ts` - App permissions status
  - `live2d.ts` - Live2D character state
  - `friendlyChat.ts` - Friendly chat feature state
- **Props/Callbacks** for parent-child communication
- **Context** for theme and global configuration
- **Tauri Events** for backend → frontend real-time updates

**Communication Pattern:**
```
User Action → Component Handler → Zustand Action → Service Layer → PyTauri Client → Backend
                                                                                      ↓
Frontend Component ← Zustand Store Update ← Response/Tauri Event ←←←←←←←←←←←←←←←←←←←←←
```

### Universal API Handler System

The project uses a **universal `@api_handler` decorator** that automatically registers backend functions for **both PyTauri and FastAPI** frameworks.

**Adding a New API Handler:**

1. Create handler in `backend/handlers/my_module.py`:
   ```python
   from . import api_handler
   from models import MyRequest

   @api_handler(
       body=MyRequest,           # Pydantic model (optional if no params)
       method="POST",            # HTTP method (for FastAPI)
       path="/my-endpoint",      # Custom path (for FastAPI)
       tags=["my-module"]        # API tags (for FastAPI docs)
   )
   async def my_handler(body: MyRequest) -> dict:
       """Handler description (auto-converted to API docs)"""
       return {"success": True, "data": body.field1}
   ```

2. Add Request Model in `backend/models/requests.py`:
   ```python
   from .base import BaseModel

   class MyRequest(BaseModel):
       """Request model inherits camelCase conversion"""
       field1: str
       field2: int = 100  # With default
   ```

3. Import module in `backend/handlers/__init__.py`:
   ```python
   from . import greeting, perception, processing, my_module
   ```

4. Regenerate TypeScript client and test:
   ```bash
   pnpm tauri:dev:gen-ts
   ```

**Key Features:**
- **Single Definition**: Works for both PyTauri (desktop) and FastAPI (web API)
- **Auto-Registration**: No manual command registration needed
- **Type Safety**: Pydantic models auto-generate TypeScript types
- **CamelCase Conversion**: Python `snake_case` ↔ JavaScript `camelCase` automatic
- **API Documentation**: FastAPI auto-generates OpenAPI/Swagger docs at `/docs`

**Critical Constraint**: PyTauri handlers MUST use a single `body` parameter with a Pydantic model. Direct parameters like `def handler(name: str)` will fail.

### Backend Handlers Reference

The project organizes handlers by feature in `backend/handlers/`:

| Handler | Purpose | Key Functions |
|---------|---------|-----------------|
| `greeting.py` | Simple greeting endpoint | Demo/test handler |
| `perception.py` | System event capture control | Start/stop monitoring, get raw events |
| `processing.py` | Activity processing pipeline | Trigger processing, merge activities |
| `agents.py` | Agent task management | List agents, execute tasks, update status |
| `chat.py` | Chat/conversation functionality | Send/receive messages, manage chat state |
| `dashboard.py` | Dashboard metrics and stats | Get statistics, activity summaries |
| `insights.py` | AI-powered insights generation | Generate insights from activities |
| `models.py` | LLM model management | List models, switch models, get config |
| `system.py` | System-level operations | Logs, app info, settings |
| `image.py` | Image processing utilities | Optimize images, generate thumbnails |
| `permissions.py` | Permission checking/requesting | Check OS permissions, request access |
| `live2d.py` | Live2D character management | Load models, control animations |
| `friendly_chat.py` | Friendly chat interactions | Schedule/trigger chat messages |
| `screens.py` | Multi-screen support | Get screen info, screenshot specific monitor |

## Key Design Patterns

### 1. Configuration-Driven Menu

Menu items in `src/lib/config/menu.ts` drive both routing and sidebar UI:
- Supports position grouping (main/bottom)
- Badge notifications
- Dynamic visibility control

### 2. PyTauri Client Auto-Generation

- Backend changes trigger automatic TypeScript client generation
- Located in `src/lib/client/` (marked as auto-generated)
- **Never manually edit client files**

### 3. Service Layer Pattern

Services in `src/lib/services/` wrap PyTauri client calls:
- Handles error logging and retry logic
- Used by Zustand store actions
- Provides clean API abstraction

**Example Service Implementation:**
```typescript
// src/lib/services/activity/index.ts
import { apiClient } from '@/lib/client'
import { logError } from '@/lib/utils/logger'

export const activityService = {
  async fetchTimeline(offset: number = 0, limit: number = 50) {
    try {
      return await apiClient.getActivities({ offset, limit })
    } catch (error) {
      logError('Failed to fetch timeline', error)
      throw error
    }
  },

  async fetchIncremental(version: number) {
    try {
      return await apiClient.getActivitiesIncremental({ version })
    } catch (error) {
      logError('Failed to fetch incremental updates', error)
      throw error
    }
  }
}

// Used in store:
export const useActivityStore = create((set) => ({
  fetchActivities: async () => {
    const activities = await activityService.fetchTimeline()
    set({ activities })
  }
}))
```

### 4. Store Subscription Optimization

```typescript
// ✅ Good: Selective subscription
const tasks = useAgentsStore((state) => state.tasks)

// ❌ Bad: Subscribe to entire store
const store = useAgentsStore()
```

### 5. Real-Time Updates via Tauri Events

Backend → Frontend real-time communication uses Tauri events for immediate UI updates without polling.

**Key Events:**
- `activity-created` - New activity added to database
- `activity-updated` - Activity modified
- `activity-deleted` - Activity removed
- `agent-task-update` - Task status changed
- `friendly-chat-trigger` - Live2D chat initiated

**Frontend Usage (Listening):**
```typescript
import { listen } from '@tauri-apps/api/event'

useEffect(() => {
  const unlisten = listen('activity-created', (event) => {
    // event.payload contains the activity data
    updateActivityStore(event.payload)
  })
  return () => unlisten.then((fn) => fn())
}, [])
```

**Backend Usage (Emitting):**
```python
# backend/core/events.py
from backend.core.events import emit_tauri_event

# Emit event to all frontend listeners
emit_tauri_event('activity-created', {
    'id': activity.id,
    'name': activity.name,
    'timestamp': activity.start_time.isoformat()
})
```

**Best Practices:**
- Always cleanup event listeners in useEffect return
- Debounce rapid events (e.g., activity updates) to avoid UI thrashing
- Use TypeScript types for event payloads to maintain type safety

## Activity Timeline Data Synchronization

The activity timeline uses a **version-based incremental update system** combined with **Tauri events**:

**Update Mechanism:**
1. **Initial Load**: `fetchActivityTimeline()` loads paginated data from database
2. **Incremental Updates**: `fetchActivitiesIncremental()` fetches new activities by version number
3. **Real-Time Events**: Tauri events (`activity-created`, `activity-updated`, `activity-deleted`) trigger updates

**Key Components:**
- `useActivityIncremental()` - Hook for incremental updates (sliding window strategy)
- `useInfiniteScroll()` - Bidirectional infinite scrolling with Intersection Observer
- `Activity/index.tsx` - Timeline view with event debouncing

**Important Implementation Details:**
1. **Event Debouncing**: Activity updates/deletes are debounced (300ms) to batch events
2. **Incremental Updates**: New activities merged at top with deduplication by date
3. **Safe Date Handling**: All timestamps validated to prevent "Invalid time value" errors
4. **Data Consistency**: Complete field mapping from backend to frontend

**Backend → Frontend Conversions:**
- `startTime` (ISO string) → `timestamp` (milliseconds)
- `sourceEvents` → `eventSummaries` with nested `events` array
- `activity.description` → `activity.name` (for display)
- `endTime` fallback to `startTime` if missing

## Internationalization (i18n)

TypeScript-first i18n with automatic type safety:

- **Translation files**: `src/locales/{en.ts, zh-CN.ts}`
- **English file** (`en.ts`) is the source of truth and defines TypeScript types
- **Type checking**: Prevents using non-existent translation keys at compile time
- **Validation**: Run `pnpm check-i18n` to ensure consistency

**Adding Translations:**
1. Add keys to `src/locales/en.ts` (always add to English first)
2. Add corresponding keys to `src/locales/zh-CN.ts` with same structure
3. Run `pnpm check-i18n` to validate
4. Use in components: `const { t } = useTranslation(); t('myFeature.title')`

See `docs/i18n.md` for detailed documentation.

## Common Development Tasks

### Adding a New Page

1. Create view component: `src/views/NewFeature/index.tsx`
2. Add menu item: `src/lib/config/menu.ts`
3. Add route with lazy loading: `src/routes/Index.tsx`
   ```typescript
   const NewFeatureView = lazy(() => import('@/views/NewFeature'))
   ```
4. Create store (if needed): `src/lib/stores/newFeature.ts`
5. Create service layer: `src/lib/services/newFeature/index.ts`

### Adding a New Agent

1. Extend `BaseAgent` in Python backend
2. Implement `execute()` and `can_handle()` methods
3. Register in `AgentFactory`
4. Update `AgentType` enum in `src/lib/types/agents.ts`
5. Add UI configuration in Agents view

### Testing Backend APIs

```bash
# Start standalone FastAPI server
uvicorn app:app --reload

# Access Swagger UI
# http://localhost:8000/docs

# Test endpoints with auto-generated documentation
```

## Git & PR Workflow

### Branch Management

```bash
# Create feature branch
git checkout -b feature/my-feature

# Create bugfix branch
git checkout -b fix/my-bugfix

# Push to remote (first time)
git push -u origin feature/my-feature

# Update from main
git fetch origin
git rebase origin/main
```

### Commit Conventions

Follow this pattern for clear commit history:

```
<type>: <description>

<optional body explaining why this change is needed>
```

**Types:**
- `feat:` - New feature
- `fix:` - Bug fix
- `refactor:` - Code restructuring without behavior change
- `docs:` - Documentation updates
- `perf:` - Performance improvements
- `test:` - Test additions/modifications
- `chore:` - Dependency updates, tooling, etc.
- `style:` - Code formatting (unrelated to logic)

**Examples:**
```
feat: add activity filtering by date range

Implements date picker in activity timeline to allow users to filter
activities within a specific time period. Updates ActivityStore to
support startDate and endDate filters.

fix: handle invalid timestamps in activity parsing

Validates ISO 8601 timestamps before creating Activity objects to
prevent "Invalid time value" errors.
```

### Creating Pull Requests

1. Push your branch and create PR from GitHub
2. Use PR template (auto-generated):
   - **Title**: Use same format as commit message
   - **Description**: Explain what changed and why
   - **Testing**: List how to test the changes
   - **Checklist**: Verify formatting, tests, i18n, docs

3. Request review from maintainers
4. Address feedback with additional commits (don't squash until merge)
5. Rebase before merging: `git rebase origin/main`

## Debugging Tips

### Frontend Debugging

**React DevTools Browser Extension:**
```bash
# Install React DevTools for your browser
# Inspect component hierarchy and state changes
# Use React Profiler to identify performance bottlenecks
```

**Zustand Store Debugging:**
```typescript
// Add logging middleware to store
export const useActivityStore = create<ActivityStore>()(
  (set, get) => ({
    // ... your store definition
  })
)

// In development, use Zustand devtools:
import { devtools } from 'zustand/middleware'

// Then inspect: https://github.com/pmndrs/zustand#how-to-use
```

**PyTauri Client Debugging:**
```typescript
// Enable logging in services
const result = await apiClient.myHandler(params)
console.log('API Response:', result)
console.error('API Error:', error)

// Check generated types in src/lib/client/index.ts
// Verify parameter names match (camelCase expected)
```

**Network Inspection:**
```bash
# Open DevTools (F12) → Network tab
# Filter by XHR/Fetch to see PyTauri calls
# Check request/response payloads and headers
```

**Timeline/Performance Debugging:**
```bash
# DevTools → Performance tab
# Record user interaction
# Analyze frame rate and component render times
```

### Backend Debugging

**Print Debugging:**
```python
from loguru import logger

# Use loguru for structured logging
logger.debug(f"Processing activity: {activity.id}")
logger.info(f"LLM response: {response}")
logger.error(f"Error processing: {error}", exc_info=True)
```

**FastAPI Server Debugging:**
```bash
# Start with detailed logging
LOGLEVEL=DEBUG uvicorn app:app --reload

# Access API docs with curl
curl -X GET "http://localhost:8000/docs"
curl -X POST "http://localhost:8000/api/my-endpoint" \
  -H "Content-Type: application/json" \
  -d '{"field1": "value"}'
```

**PyTauri Handler Debugging:**
```python
# Test handler directly in Python REPL
from backend.handlers.my_module import my_handler
from backend.models.requests import MyRequest

result = await my_handler(MyRequest(field1="test"))
print(result)
```

**Database Inspection:**
```bash
# Examine SQLite database directly
sqlite3 backend/data/rewind.db

# List tables
.tables

# Query activities
SELECT id, name, start_time FROM activities LIMIT 5;
```

### Integration Debugging

**Full Stack Testing with Logging:**
```bash
# Terminal 1: Start backend with debug logging
LOGLEVEL=DEBUG pnpm tauri dev

# Terminal 2: Open DevTools (F12)
# Observe both frontend and backend logs simultaneously

# Check console for errors and network activity
```

**State Synchronization Issues:**
```typescript
// If Tauri events not triggering UI updates:
// 1. Verify event listener is set up in useEffect
// 2. Check backend is emitting event at correct time
// 3. Validate event payload structure matches frontend expectations
// 4. Use console.log to trace event delivery
```

## Common Error Messages & Quick Fixes

### PyTauri Errors

**Error: `handler function expected to be an async function`**
```
✅ Fix: Add `async` keyword to handler definition
async def my_handler(body: MyRequest) -> dict:
```

**Error: `Failed to serialize response`**
```
✅ Fix: Ensure handler returns JSON-serializable data
# Instead of: return activity (SQLAlchemy object)
# Do: return activity.model_dump()
```

**Error: `TypeError: expected 1 argument (body), got 0`**
```
✅ Fix: Must pass a Pydantic model body
# Instead of: apiClient.myHandler()
# Do: apiClient.myHandler({ fieldName: value })
```

### Frontend Type Errors

**Error: `Cannot find module or its corresponding type declarations`**
```
✅ Fix: Regenerate TypeScript client
pnpm tauri:dev:gen-ts
# Then restart the dev server
```

**Error: `Property 'X' does not exist on type 'Activity'`**
```
✅ Fix: Check if API response changed
# 1. Check backend model definition
# 2. Run pnpm tauri:dev:gen-ts to regenerate types
# 3. Update frontend code to use correct field names
```

**Error: `Invalid time value` when parsing dates**
```
✅ Fix: Use safe date parsing function
const timestamp = parseDate(activity.startTime)
// Instead of: new Date(activity.startTime).getTime()
```

### Backend Errors

**Error: `ModuleNotFoundError: No module named 'X'`**
```
✅ Fix: Synchronize Python environment
pnpm setup-backend
# Run from project root, not src-tauri/
```

**Error: `LLM API key not configured`**
```
✅ Fix: Set OpenAI API key in environment or settings
# Set OPENAI_API_KEY environment variable
export OPENAI_API_KEY="sk-..."
# Or configure via app settings UI
```

**Error: `Permission denied: screenshot capture failed`**
```
✅ Fix: Grant app permissions
# macOS: System Settings → Privacy & Security → Screen Recording
# Windows: App needs to be run as administrator (or requested)
# Grant permission and restart app
```

### Build Errors

**Error: `target not found: 'target/release'` on Windows**
```
✅ Fix: Build artifacts are missing
pnpm clean
pnpm tauri build
# Rebuild from scratch
```

**Error: `Python environment not found`**
```
✅ Fix: .venv is in wrong location or broken
# Delete and recreate
rm -rf .venv
pnpm setup-backend
pnpm tauri dev
```

**Error: `CRLF vs LF line ending issues` on Windows**
```
✅ Fix: Configure git immediately after clone
git config core.autocrlf false
# Then remove and re-add files if already committed
git rm --cached -r .
git reset --hard
```

## Enhanced Testing Section

### Running Specific Tests

```bash
# Run all backend tests with pytest
cd backend
python -m pytest

# Run specific test file
python -m pytest tests/perception/test_factory.py

# Run specific test function
python -m pytest tests/perception/test_factory.py::test_factory_initialization

# Run tests with output
python -m pytest -v

# Run tests with coverage
python -m pytest --cov=backend --cov-report=html
```

### Mocking Strategies

**Frontend - Mocking API Calls:**
```typescript
// Mock the service in tests
jest.mock('@/lib/services/activity', () => ({
  activityService: {
    fetchTimeline: jest.fn().mockResolvedValue([
      { id: 1, name: 'Activity 1', timestamp: Date.now() }
    ])
  }
}))

// Or use MSW (Mock Service Worker) for integration tests
```

**Backend - Mocking LLM Calls:**
```python
from unittest.mock import patch, AsyncMock

@patch('backend.llm.openai_client.chat.completions.create')
async def test_activity_summarization(mock_llm):
    mock_llm.return_value = AsyncMock(
        choices=[AsyncMock(message=AsyncMock(content="Test summary"))]
    )
    # Test code here
```

### Pre-commit Validation

```bash
# Run all checks before committing
pnpm format
pnpm lint
pnpm check-i18n
pnpm build

# This ensures CI will pass
```

## Dependency Management

### Frontend Dependencies

```bash
# Check for outdated packages
pnpm outdated

# Update specific package
pnpm update react@latest

# Update all packages (be careful!)
pnpm update -r

# Add new dependency
pnpm add package-name
```

### Backend Dependencies

```bash
# Check for outdated packages in Python
uv pip list --outdated

# Update all dependencies
uv sync --upgrade

# Add new dependency
uv pip install package-name
# Then update pyproject.toml accordingly
```

### Safe Update Workflow

1. **Test on feature branch**
   ```bash
   git checkout -b chore/update-dependencies
   ```

2. **Update dependencies**
   ```bash
   pnpm update  # or uv sync --upgrade
   ```

3. **Run full test suite**
   ```bash
   pnpm format
   pnpm lint
   pnpm check-i18n
   pnpm build
   pnpm tauri build
   ```

4. **Test manually**
   ```bash
   pnpm tauri dev
   # Test critical features manually
   ```

5. **Commit and create PR**
   ```bash
   git add .
   git commit -m "chore: update dependencies"
   ```

## Performance Profiling

### Frontend Performance

**React Profiler:**
```bash
# 1. Open DevTools → Profiler tab
# 2. Record a user interaction
# 3. Analyze flame chart to identify slow components
# 4. Look for unnecessary re-renders
```

**Component Memoization:**
```typescript
// If a component re-renders unnecessarily:
const MyComponent = React.memo(({ data, onUpdate }) => {
  return <div>{data}</div>
})

// Profile before/after to verify improvement
```

**Bundle Size Analysis:**
```bash
# Analyze bundle size
pnpm build

# Check which imports are largest
# Use Webpack Bundle Analyzer or similar tool
```

### Backend Performance

**Query Performance:**
```python
# Log slow queries
from sqlalchemy import event
from sqlalchemy.pool import Pool

@event.listens_for(Pool, "connect")
def receive_connect(dbapi_conn, connection_record):
    dbapi_conn.enable_load_extension("./query_profiler")
```

**LLM API Performance:**
```python
import time

start = time.time()
response = await llm_client.call(prompt)
elapsed = time.time() - start
logger.info(f"LLM call took {elapsed:.2f}s")
```

**Memory Usage:**
```bash
# Monitor memory during development
python -m memory_profiler scripts/test_full_pipeline.py
```

## IDE Configuration & Extensions

### Recommended VS Code Extensions

```json
{
  "recommendations": [
    "dbaeumer.vscode-eslint",           // ESLint
    "esbenp.prettier-vscode",            // Prettier formatter
    "firsttris.vscode-jest-runner",      // Jest test runner
    "ms-python.python",                  // Python support
    "ms-python.vscode-pylance",          // Python type checking
    "GitHub.copilot",                    // AI code suggestions
    "bradlc.vscode-tailwindcss",         // Tailwind CSS IntelliSense
    "Vue.volar",                         // Vue/React support
    "paulmolluzzo.react-comment-templates", // React snippets
    "eamodio.gitlens",                   // Git integration
    "wayou.vscode-todo-highlight",       // TODO highlighting
    "shardulm94.trailing-spaces"         // Remove trailing spaces
  ]
}
```

**Install extensions:**
```bash
code --install-extension dbaeumer.vscode-eslint
code --install-extension esbenp.prettier-vscode
# ... etc
```

### VS Code Settings

**Create/update `.vscode/settings.json`:**
```json
{
  // Formatting
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[python]": {
    "editor.defaultFormatter": "ms-python.python",
    "editor.formatOnSave": true
  },

  // TypeScript
  "typescript.enablePromptUseWorkspaceTsdk": true,
  "typescript.tsdk": "node_modules/typescript/lib",

  // Python
  "python.linting.enabled": true,
  "python.linting.pylintEnabled": true,

  // File association
  "files.associations": {
    "*.ts": "typescript",
    "*.tsx": "typescriptreact"
  },

  // Excluded folders
  "files.exclude": {
    "**/__pycache__": true,
    "**/node_modules": true,
    "**/dist": true
  },

  // Tailwind CSS
  "tailwindCSS.experimental.classRegex": [
    ["cva\\(([^)]*)\\)", "(?:'|\"|`|{\\s*)([^']*)(?:'|\"|`|})"]
  ]
}
```

### PyCharm Configuration (if using)

**Recommended settings:**
- Python interpreter: Point to `.venv/`
- Run configuration: Set working directory to project root
- Inspections: Enable type checking for async code
- Markdown support: For editing docs

### Development Server Shortcut

```bash
# Create shell alias for faster development
alias rewind-dev='cd ~/Workspace/Rewind && pnpm tauri:dev:gen-ts'
alias rewind-api='cd ~/Workspace/Rewind && uvicorn app:app --reload'
alias rewind-format='cd ~/Workspace/Rewind && pnpm format && pnpm lint'
```

## File Structure Conventions

### Do Not Edit (Auto-Generated)

- `src/lib/client/` - Auto-generated PyTauri client code
- `src/components/shadcn-ui/` - Generated shadcn/ui components (edit via CLI only)
- `src/types/auto-imports.d.ts` - Auto-generated types

### Key Directories

- `src/views/` - Page-level components (route targets)
- `src/layouts/` - Layout wrappers (MainLayout, AuthLayout)
- `src/lib/stores/` - Zustand state management
- `src/lib/services/` - API service layer (wraps PyTauri client)
- `src/lib/types/` - TypeScript type definitions
- `src/lib/config/` - Configuration files (menu, constants)
- `src/components/` - Reusable components organized by feature
- `src/hooks/` - Custom React hooks
- `backend/` - Python backend code (symlinked to `src-tauri/python/`)
- `backend/handlers/` - API handlers using `@api_handler` decorator
- `backend/models/` - Pydantic data models

### Naming Conventions

- **Components**: PascalCase (`ActivityTimeline`)
- **Hooks**: camelCase with `use` prefix (`useActivityStore`)
- **Types**: PascalCase (`Activity`, `AgentTask`)
- **Constants**: UPPER_SNAKE_CASE (`MAX_RETRY_COUNT`)
- **Python Functions**: snake_case (auto-converts to camelCase for TypeScript)

## Defensive Programming Patterns

### Date/Timestamp Validation

```typescript
// ✅ Safe date parsing with fallback
const parseDate = (dateStr: string | undefined | null): number => {
  if (!dateStr) return Date.now()
  const parsed = new Date(dateStr).getTime()
  return isNaN(parsed) ? Date.now() : parsed
}
```

### Optional Property Access

```typescript
// ✅ Always use optional chaining for potentially undefined fields
{activity.eventSummaries?.length ?? 0}
{(activity.eventSummaries ?? []).map(...)}
```

### Loading State Awareness

- Check `loading || isRefreshing || loadingMore` before showing empty states
- Show loading indicator when data is loading, empty state only when truly empty

### Error Handling Patterns

**Frontend Error Handling:**
```typescript
// ✅ Good: Comprehensive error handling
try {
  const result = await activityService.fetchActivities()
  set({ activities: result, error: null })
} catch (error) {
  const message = error instanceof Error ? error.message : 'Unknown error'
  set({ error: message, loading: false })
  toast.error(`Failed to load activities: ${message}`)
}

// For async operations in stores:
const fetchWithLoading = async (asyncFn: () => Promise<T>) => {
  set({ loading: true })
  try {
    const result = await asyncFn()
    set({ loading: false })
    return result
  } catch (error) {
    set({ loading: false, error: String(error) })
    throw error
  }
}
```

**Backend Error Handling:**
```python
# ✅ Good: Proper error handling in handlers
@api_handler(body=MyRequest)
async def my_handler(body: MyRequest):
    try:
        result = await process_activity(body)
        return {"success": True, "data": result}
    except ValueError as e:
        logger.error(f"Validation error: {e}")
        return {"success": False, "error": str(e), "code": "validation_error"}
    except Exception as e:
        logger.error(f"Unexpected error: {e}", exc_info=True)
        return {"success": False, "error": "Internal server error", "code": "internal_error"}
```

## Common Pitfalls

### Pitfall 1: Modifying Auto-Generated Files

**Problem:** Editing files that are automatically generated will cause your changes to be overwritten.

**Files to NEVER manually edit:**
- ❌ `src/lib/client/` - Auto-generated PyTauri TypeScript client
- ❌ `src/components/ui/` - shadcn/ui components (use CLI to modify)
- ❌ `src/types/auto-imports.d.ts` - Auto-generated type definitions

**Solution:** Always modify the source (Python handlers or use shadcn CLI for UI components).

### Pitfall 2: Forgetting to Import Handler Modules

**Problem:** Created a new handler but it doesn't appear in TypeScript client or FastAPI docs.

**Solution:** Always import new handler modules in `backend/handlers/__init__.py`:

```python
# backend/handlers/__init__.py
from . import (
    greeting,
    perception,
    processing,
    system,
    agents,
    chat,
    my_new_handler,  # ← ADD THIS LINE
)
```

Then run: `pnpm setup-backend && pnpm tauri dev`

### Pitfall 3: Incorrect Python Environment Location

**Problem:** Running `uv sync` or installing packages in wrong directory.

**Critical:** Python environment is at **PROJECT ROOT**, not `src-tauri/`!

```
✅ Correct:
Rewind/.venv/                  ← Python environment HERE
Rewind/pyproject.toml          ← Python config HERE

❌ Wrong:
Rewind/src-tauri/.venv/        ← DON'T create here
```

**Solution:** Always run `pnpm setup-backend` from project root.

### Pitfall 4: Date Handling Errors

**Problem:** "Invalid time value" errors when parsing dates from backend.

**Solution:** Always validate dates before using:

```typescript
// ❌ Bad: Can throw "Invalid time value"
const timestamp = new Date(activity.startTime).getTime()

// ✅ Good: Safe with fallback
const parseDate = (dateStr: string | undefined | null): number => {
  if (!dateStr) return Date.now()
  const parsed = new Date(dateStr).getTime()
  return isNaN(parsed) ? Date.now() : parsed
}
const timestamp = parseDate(activity.startTime)
```

### Pitfall 5: Windows Line Endings

**Problem:** Git shows many files as modified with no actual changes, or merge conflicts with line endings.

**Solution:** On Windows, always configure git immediately after cloning:

```bash
git config core.autocrlf false
```

**Why:** Windows uses CRLF (`\r\n`) while Unix uses LF (`\n`). This setting prevents automatic conversion that causes issues in cross-platform development.

### Pitfall 6: PyTauri Handler Parameter Constraints

**Problem:** PyTauri handler fails with parameter errors.

**Critical Constraint:** PyTauri handlers MUST use either:
- No parameters, OR
- A single `body` parameter with a Pydantic model

```python
# ❌ Wrong: Multiple parameters
@api_handler()
async def my_handler(arg1: str, arg2: int):
    pass

# ❌ Wrong: Direct primitive parameter
@api_handler()
async def my_handler(name: str):
    pass

# ✅ Correct: No parameters
@api_handler()
async def my_handler() -> dict:
    return {"status": "ok"}

# ✅ Correct: Single body parameter
@api_handler(body=MyRequest)
async def my_handler(body: MyRequest) -> dict:
    return {"data": body.field1}
```

### Pitfall 7: Zustand Store Subscriptions

**Problem:** Component re-renders excessively, causing performance issues.

**Solution:** Use selective subscriptions, not entire store:

```typescript
// ❌ Bad: Subscribes to entire store, re-renders on any change
const store = useActivityStore()

// ✅ Good: Only subscribes to specific state
const activities = useActivityStore((state) => state.activities)
const isLoading = useActivityStore((state) => state.loading)
```

## Performance Considerations

- **Lazy Loading**: All route components use React.lazy for code splitting
- **Virtual Scrolling**: Used for long lists (activity timeline)
- **Memoization**: Apply React.memo to pure presentational components
- **Store Subscriptions**: Always use selectors to minimize re-renders
- **Image Optimization**: Backend compresses screenshots and uses perceptual hashing for deduplication
- **Batch Processing**: Backend processes events every 10 seconds to reduce LLM calls

## Quick File Location Reference

Need to find something? Here's where to look:

| Task | File Location |
|------|----------|
| Add new UI page | Create in `src/views/MyFeature/index.tsx`, add route in `src/routes/Index.tsx` |
| Add global state | Create store in `src/lib/stores/myFeature.ts` |
| Add API wrapper | Create service in `src/lib/services/myFeature/index.ts` |
| Add backend endpoint | Create handler in `backend/handlers/myModule.py` |
| Add UI component | Create in `src/components/MyComponent/` |
| Add type definitions | Add to `src/lib/types/index.ts` |
| Configure menu/routing | Edit `src/lib/config/menu.ts` |
| Change theme colors | Edit `tailwind.config.ts` and theme provider in `src/` |
| Add translation | Edit `src/locales/en.ts` and `src/locales/zh-CN.ts` |
| Fix Python environment issues | Check `.venv/` and `pyproject.toml` at project root |
| Debug API responses | Check `backend/models/` for request/response shapes |
| Add system permissions | Edit `backend/system/permissions.py` |
| Configure LLM/OpenAI | Edit settings in `backend/handlers/models.py` |

## Important Files and Documentation

**Core Documentation** (start here for detailed information):
- `docs/development.md` - Complete setup and development workflow guide
- `docs/architecture.md` - System architecture overview
- `docs/frontend.md` - Frontend architecture documentation
- `docs/backend.md` - Backend system design documentation
- `docs/api_handler.md` - Universal API handler system documentation
- `docs/i18n.md` - Internationalization configuration
- `docs/fastapi_usage.md` - FastAPI standalone server usage
- `docs/python_environment.md` - Python environment management

**Frontend Key Files:**
- `src/lib/config/menu.ts` - Menu configuration (affects routing and UI)
- `src/routes/Index.tsx` - Application routing definition
- `src/lib/stores/` - Zustand state management stores
- `src/lib/client/` - Auto-generated PyTauri TypeScript client (DO NOT EDIT)

**Backend Key Files:**
- `app.py` - FastAPI application entry point (standalone server)
- `backend/handlers/__init__.py` - Universal API handler decorator and registration
- `backend/handlers/{greeting,perception,processing,system,agents}.py` - API handler modules
- `backend/models/base.py` - Pydantic BaseModel with camelCase conversion
- `backend/models/requests.py` - Request model definitions
- `src-tauri/python/rewind_app/__init__.py` - PyTauri command registration entry point

**Configuration:**
- `pyproject.toml` - Python project configuration (at project root)
- `package.json` - Node.js dependencies and scripts
- `src-tauri/Cargo.toml` - Rust dependencies including PyTauri
- `src-tauri/src/lib.rs` - Rust-Python bridge configuration

## Special Notes

### ⚠️ CRITICAL: Python Environment Location

**THE PYTHON VIRTUAL ENVIRONMENT IS AT THE PROJECT ROOT, NOT IN `src-tauri/`!**

```
✅ Correct Structure:
Rewind/
├── .venv/              ← Python virtual environment HERE
├── pyproject.toml      ← Python configuration HERE
├── src/                ← Frontend code
├── src-tauri/
│   ├── python/        ← Python source code here
│   └── Cargo.toml
└── backend/           ← Symlink to src-tauri/python (or actual code)
```

**Critical Commands:**
- `pnpm setup-backend` - Re-sync Python environment at **project root**
- `uv sync` - Install Python packages (run from **project root**)
- After ANY Python changes: `pnpm setup-backend && pnpm tauri dev`

**Why This Matters:**
- PyTauri needs to find the .venv at project root during build
- Running `uv sync` in wrong directory creates invalid environment
- Wrong environment location causes cryptic build errors

### Other Important Notes

- **TypeScript Strict Mode**: Project uses strict TypeScript settings
- **Path Aliases**: Use `@/*` for imports from `src/`
- **Theme System**: next-themes provider for light/dark mode
- **Form Validation**: Use React Hook Form + Zod schema validation
- **Error Boundaries**: Wrap major sections for graceful error handling
- **Activity Timeline UI**: Maintains consistent styling across items with subtle entrance animations
- **Windows Development**: Always run `git config core.autocrlf false` to prevent line ending issues

## Data Models (Backend)

- `RawRecord` - Raw input events (timestamp, type, data)
- `Event` - Filtered and summarized events
- `Activity` - Grouped related events with LLM-generated description
- `Task` - Agent tasks with execution state (todo/doing/done/cancelled)

## Agent System Architecture

- **Factory Pattern**: `AgentFactory` for extensible agents
- **Base Class**: `BaseAgent` with `execute()` and `can_handle()` methods
- **Task States**: `todo`, `doing`, `done`, `cancelled`
- **Parallel Execution**: Supports running multiple agents concurrently

## Live2D Integration

The application includes a Live2D mascot feature with interactive chat capabilities:

**Key Components:**
- `backend/handlers/live2d.py` - Live2D model configuration and state management
- `backend/handlers/friendly_chat.py` - Scheduled friendly chat interactions with the user
- `backend/services/friendly_chat_service.py` - Chat service implementation
- Frontend uses `pixi-live2d-display` library (PixiJS 6.5.6) for rendering

**Features:**
- Live2D character displays in sidebar/floating panel
- Automatic friendly chat triggers based on timers or events
- Hover interactions and state changes
- Customizable models and expressions

**Adding/Modifying Live2D Models:**
1. Place model files in appropriate directory
2. Update configuration via `live2d.py` handlers
3. Frontend components will automatically load new models

**Event Flow:**
```
Timer/User Action → friendly_chat_service.py
    ↓
Emit 'friendly-chat-trigger' event
    ↓
Frontend receives event → Display chat message
    ↓
Live2D model shows animation/expression
```

## System Permissions

The application requires specific OS permissions to capture user activity:

### Required Permissions

**macOS:**
- **Screen Recording** - Required for screenshot capture
- **Accessibility** - Required for keyboard and mouse monitoring
- **Input Monitoring** - Required for detailed event capture

**Windows:**
- **Input Monitoring** - For keyboard/mouse event capture
- **Screen Capture** - For screenshot functionality

**Linux:**
- **X11/Wayland Access** - For event monitoring
- **Screen Capture** - For screenshot functionality

### Permission Handling

**Backend Implementation:**
- `backend/system/permissions.py` - Permission checking and requesting logic
- `backend/handlers/permissions.py` - API handlers for permission status
- Platform-specific permission requests via PyObjC (macOS) or native APIs

**Frontend Integration:**
- Permission checks happen at app startup via `useBackendLifecycle()` hook
- Users are prompted to grant permissions if missing
- Permission status displayed in system status indicator
- Graceful degradation if permissions are denied

**Checking Permissions:**
```python
# Backend
from backend.system.permissions import check_permissions, request_permissions

status = await check_permissions()
if not status.all_granted:
    await request_permissions()
```

```typescript
// Frontend
import { checkPermissions } from '@/lib/client'

const status = await checkPermissions()
if (!status.allGranted) {
  // Show permission prompt UI
}
```

**Important Notes:**
- App functionality is limited without proper permissions
- Permission requests may require app restart on some platforms
- See `docs/PERMISSIONS_*.md` for detailed implementation guides
